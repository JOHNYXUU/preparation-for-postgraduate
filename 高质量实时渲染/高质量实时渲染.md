# 第一课 图形学回顾

## 渲染管线Graphics pipeline

顶点处理->三角形处理->光栅化->遮挡->着色

![](图片\QQ截图20210616155706.png)

## 渲染方程

描述光线传播的等式

![](图片\QQ截图20210616170048.png)

# 第二课 实时阴影

## shadow mapping

两趟算法，分别从光源看、从相机看

能被光源看到的，不存在阴影；看不到的则存在阴影

优点：实现简单、开销小

缺点：自遮挡（深度记录不连续，眼睛看的位置被橙线挡住）、走样

![](图片\QQ截图20210616201207.png)

自遮挡解决：一小段内的遮挡不算阴影，但造成了新的问题，有些阴影没有显示出来

![](图片\QQ截图20210616201647.png)

## 近似技巧

两个函数乘积积分，近似为分别积分的乘积/常数（用来归一化）

积分域比较小、g(x)比较光滑的时候比较准确

![](图片\QQ截图20210616204038.png)

可以把渲染方程转换

![](图片\QQ截图20210616204607.png)

## percentage closer soft shadows(PCSS)

SM会产生硬阴影，但实际大多数阴影是软阴影

### percentage closer filtering

一开始用来处理SM中的走样问题

从光看向场景时，不只找一个像素，而是找周围一圈的像素，计算他们到光源的距离，

看他们是否是否被遮挡

**计算量明显增加**

![](图片\QQ截图20210616210147.png)

得出来的值是一个[0,1]的数，而不是非0即1，这样才能得出软阴影

![](图片\QQ截图20210618172651.png)

### pcss

我们发现pcf，filter size越大，阴影越软

那么filter size的如何确定？

我们发现，离遮挡物远的阴影一般为软阴影，离遮挡物近的阴影一般为硬阴影

那我们采取近处的size小，远处的size大



那么怎么计算阴影离遮挡物的距离呢？

根据相似三角形

Wpenumbra半阴影范围，越大阴影越软

![](图片\QQ截图20210616211836.png)

步骤

1、算一个区域的平均遮挡物深度（blocker depth，遮挡物到阴影点的距离）

2、使用平均遮挡物深度决定filter size

3、pcf

但首先得确定范围内的遮挡物大小，那么要取多大的区域呢？

可以设置一个定值，也可以根据光源的大小和接受物到光源的距离决定（开销大）

![](图片\QQ截图20210616213844.png)

## Variance Soft Shadow Mapping

pcss的第一步和第三步很慢，需要求一块像素的深度的均值

### 优化第三步

我们可以近似的认为这是一个**正态分布**，使用正态分布来求解则需要**均值和方差**

V（可视程度）= 正态分布中 x <= depth 的面积的大小（概率）

加速求均值：MIPMAP或SAT（**二维前缀和！！！！**）

求方差：$Var(X)=E(X^2)-E^2(X)$

我们只需要多记录**深度平方的均值**，即可求出方差

再使用切比雪夫不等式，求概率（t在均值右边比较准）

![](图片\QQ截图20210618175934.png)

步骤：

场景移动则需要更新MIPMAP

![](图片\QQ截图20210618180912.png)

### 优化第一步

我们采样周围一圈像素的深度，计算遮挡物（**深度小于shading points的为遮挡物**）的均值

图中为蓝色的（t=7）为遮挡物

红色的为非遮挡物

![](图片\QQ截图20210618181631.png)

可以这么算，$N_1$遮挡物的个数，$N_2$是非遮挡物个数

![](图片\QQ截图20210618192638.png)

计算$\frac{N_1}{N}$的方法和优化第三步的方法一样（正态分布/切比雪夫不等式）

再假设非遮挡物的深度为 t （shading points深度）。。。。。

![](图片\QQ截图20210618193116.png)

### SAT

**二维前缀和**来求矩形的和

预计算二维前缀和。

![](图片\QQ截图20210618194609.png)

如何快速建立？

## moment shadow mapping

比较前沿

VSSM可能漏光（light leaking），近似的分布和实际的分布差别很大

![](图片\QQ截图20210618200059.png)

moment（矩）

VSSM使用二阶矩估计来近似分布的值

四阶矩估计就可以比较理想了（但开销大）

## Distance field soft shadows

### SDF

物体周围的点，到物体的最短距离

下图以分界线为计算的位置，右边距离大于零，左边小于零，可以用来做A->B的线性插值

![](图片\QQ截图20210621160444.png)

### 应用

1、光线求交

当计算出一个物体的SDF以后，可以知道任何一个点到他的**最小距离**。

那么在这个**最小距离**内，永远不可能和这个点相交。

那我们，就让光线沿它的方向移动这么远，每次都移动SDF上的距离

直到这个距离足够小（相交），或者光线移动了很远（没有相交）

![](图片\QQ截图20210621161700.png)

2、求阴影的值

从某个shading points往光源看过去，safe angle越小，我们认为阴影越大

![](图片\QQ截图20210621162212.png)

具体的确定方法是，根据应用1的方法，一步一步算多个角度，最终取最小的

![](图片\QQ截图20210621162624.png)

计算角度可以用arcsin来做，但是计算量比较大，算个大概的值就行了，**k太大了，阴影会很锐利**

![](图片\QQ截图20210621162831.png)

缺点：需要预处理出距离场（三维的），存储量很大

# 第三课 环境光照

## 定义

一张记录从任何一个距离来的光的图像

![](图片\QQ截图20210621165052.png)

## 使用环境光照渲染场景

### Split Sum

1、 预先对环境光做滤波prefiltering

目的：BRDF中需要对周围一圈做采样然后取均值，预先处理可以提前把均值求出来，**即公式前半部分的值**

![](图片\QQ截图20210621171701.png)

![](图片\QQ截图20210621171041.png)

2、 求公式第二项的值

如何可以避免采样呢？

 各种数学。。。把BRDF近似，让结果可以预处理

![](图片\QQ截图20210621173654.png)

### 预备知识

一个函数可以由多个函数之和来表示

比如傅里叶变换就是使用一系列不同频率的三角函数组成f(x)的

这些三角函数称为基函数basic function

![](图片\QQ截图20210621200207.png)

### 球面谐波函数

一系列定义在球上的二维基函数，频率不同，类似一维的傅里叶级数

![](图片\QQ截图20210621200934.png)

我们用这些基函数表示一个f(w)（比如环境光，从四面八方来，是一个球面函数）

那么怎么求基函数前面的系数c呢？

对应位置积分即可

![](图片\QQ截图20210621201828.png)

比较适合描述一些**低频diffuse的光照**，前三阶的基函数就可以描述的很好了

![](图片\QQ截图20210621204133.png)

### PRT precomputed radiance transfer

#### 基本思想

把渲染方程BRDF分成两个部分，lighting 和 light transport

1、使用基函数近似lighting

2、light transport对于每一个shading point是不变的，我们可以把它预处理出来

包括visibility、brdf和cos项

![](图片\QQ截图20210621205327.png)

#### diffuse情况

预处理后，只需要点乘即可得到结果

![](图片\QQ截图20210621205946.png)

问题：假如某个物体运动，整个就不对了

优点：1、支持旋转2、、、

![](图片\QQ截图20210621210625.png)

#### glossy情况

计算量更大

![](图片\QQ截图20210622161744.png)

#### 缺点

1、低频，只适合diffuse物体

2、场景、材质是固定的，不能动

3、预计算数据很大

# 第四课 实时全局光照

## 基本概念

1、实时全局光照中，我们只计算**一次**间接光照

2、一切被直接光照的物体，都为作为**次级光源**照亮别的物体

3、哪些面是被直接照亮的？**shadow map**可以做这件事，并假设次级光源是diffuse的

4、每一个面光源对点p的贡献是多少？

## RSM reflective shadow maps

### 方法

使用shadow map找到被直接光照到的面，把这些面当做次级光源，照亮别的点。

并假设这些次级光源的表面都是diffuse的，因为这样比较好算它反射出去的radiance

但对于所有的p，都要在整个shadow map上查询的话，就太慢了

所以我们需要找点p周围的一些点来计算，但世界坐标也太大了

所以就**大胆假设**，点p在**shadow map周围的点**，在世界坐标下离p比较近，算这些就行了

![](图片\QQ截图20210622172728.png)

### 存储信息

在shadow map的基础上多存了一些值

深度、世界坐标、法线、流明

在游戏中**手电筒**的效果很适合

![](图片\QQ截图20210622173727.png)

### 优点、缺点

优点：实现简单

缺点：1、性能和直接光源的数量线性相关 2、没有做p到q是否可视的处理（不好做）3、假设很多

## Light Propagation Volumes LPV

### 步骤

1、找到次级光源（RSM的方法），获得虚拟光源

![](图片\QQ截图20210622195728.png)

2、注入，先把屏幕分成 3D的网格

对于任何一个格子内部，都可能有一些虚拟的光源

记录这些虚拟光源到各个方向的radiance，并用SH（球面谐波函数4个即可，2阶）来表示

![](图片\QQ截图20210622200138.png)

3、传播，对每一个格子，让内部的radiance怎么到6个方向，

重复这个步骤，直到所有的网格内部的radiance稳定下来

![](图片\QQ截图20210622200502.png)

4、渲染，计算每个格子内部的从各个方向来的radiance，着色即可

## Voxel Global Illumination VXGI

### 步骤

1、把场景分成小格子，建立层级关系

2、记录每一个格子表面的法线，和光源的方向

![](图片\QQ截图20210622202348.png)

3、嗨呀，看不懂、、、、

![](图片\QQ截图20210622202621.png)

## Screen Space Ambient Occlusion SSAO 环境光遮蔽

### screen space

屏幕空间的意思是，使用的信息都在屏幕上。

换句话说，是在直接光照的基础上进行后期处理，所获得的信息都来自直接光照

### 什么是SSAO

1、是一种对环境光照的**近似**

2、在屏幕空间中

### 核心想法

1、假设所有方向来的间接光照都是一个常数

2、但并不是所有方向都可以接收到，有一些**环境光被遮蔽**了

3、假设物体diffuse

从渲染方程出发解释

首先，可以做下图的近似，函数乘积的积分可以近似地拆分成两个积分的乘积

该近似在g(x)的**覆盖范围小，且平滑的时候准**，而AO中是常数，绝对平滑！

![](图片\QQ截图20210622205203.png)

再把渲染方程的Visibility项和Light+BRDF拆分，

蓝色部分，积分成了visibility的平均

而由于假设了物体表面是diffuse的，因此BRDF是常数，橙色的项也很好求

![](图片\QQ截图20210622205135.png)

### 如何计算visibility？

假如是**图像空间**内，可以计算上半球内的光有多少被遮挡，只考虑一段距离内的

![](图片\QQ截图20210622211433.png)

屏幕空间没办法这么做， 知道的信息很少

我们有的是深度图depth_buffer

我们在shading point周围一个球内取一些点

这些点到相机的深度假如比depth_buffer记录的大，那么这些位置就被遮蔽了（在物体内部）

![](图片\QQ截图20210622212014.png)

但其实只有半个球体内有贡献，但是当年屏幕空间中记录法线信息

所以我们只在**红点个数过半**的情况下（也是一种假设），才考虑**环境光遮蔽**问题，否则**认为没有遮蔽**

现在已经有法线值了（**HBAO**），可以得到更加准确的值

