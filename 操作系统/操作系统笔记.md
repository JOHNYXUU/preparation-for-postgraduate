# 一、概述

## 作用

负责管理协调软硬件等计算机资源

合理组织调度计算机工作和资源的分配

给用户和软件方便的接口和环境，是计算机系统中最基本的**系统软件**

## 功能

### 作为资源管理者

**处理机管理、存储器管理、文件管理、设备管理**

目标：安全高效

### 作为用户和硬件之间的接口

命令接口（联机命令接口（用户给一句命令，系统执行一句）、脱机命令接口（用户给一堆命令，系统执行一堆））

程序接口（系统调用.dll文件）：用户通过程序间接使用

GUI

目标：方便用户使用

### 作为最接近硬件的层次

对硬件机器扩展

## 特征

### 并发

两个及以上个事件在同一时间间隔内发生。宏观上同时发生，微观上交替发生

**并行**：多个事件在同一时刻同时发生

cpu一个核心只能同时处理一个任务，所以必须做到并发，才能同时运行大量的程序

### 共享

系统中的资源可供内存中多个并发执行的进程同时使用

**互斥共享方式**：一段时间内只允许一个进程访问该资源

**同时共享方式**：一段时间内允许多个进程“同时”访问，这里的同时指的是并发，微观上交替访问

所以并发性和共享性是互为存在条件的

### 虚拟

物理上的实体变为若干个逻辑上的对应物，物理实体实际存在，逻辑上的对应物是用户感受到的。

比如：所有程序正常运行所需内存>电脑实际内存，但可以正常运行；正在运行的程序数目>计算机cpu核心数,但可以正常运行

空分复用基数：如虚拟存储器技术

时分复用技术：如虚拟处理器技术

**假如没有并发性就不可能实现虚拟性**

### 异步

系统资源有限，并发进程的执行不是一贯到底的，而是走走停停的，所以进程的推进速度不可预知

同样需要并发

## 中断机制

中断发生后，运行的进程暂停运行，cpu进入核心态（可以执行特权指令），并由操作系统内核对中断进行处理，不同的中断信号，进行不同的处理

内中断：来源于cpu内部，自愿中断，比如指令中断
外中断：来源于cpu外部，比如外设请求、人工干预

## 系统调用

cpu必须在核心态下

设备管理、文件管理、进程控制、进程通信、内存管理

# 二、进程

## 定义

每一个程序在运行中都会占据内存的一个**数据段**和一个**程序段**

为了描述进程的各种信息（比如进程在内存中的位置），我们引入**PCB（进程控制块）**来描述这些信息。

**数据段、程序段、PCB构成了进程实体（即进程）**

**进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位**。

## 组成

![](图片\QQ截图20210602164858.png)

![](图片\QQ截图20210602165005.png)

## 组织方式

链接方式

由执行指针、就绪队列指针、阻塞队列指针组织

![](图片\QQ截图20210602165558.png)

索引方式

指针指向索引表，表内存放PCB的指针

![](图片\QQ截图20210602165910.png)

## 特征

动态性：进程会动态地产生、变化、消亡

并发性：多个进程实体并发执行

**独立性：进程是独立运行、获得资源、接受调度的基本单位**
异步性：进程各自独立、并发执行，所以推进速度不可预知

结构性：结构上都由PCB、程序段、数据段组成

## 状态和转换

运行态：几个核心就可以同时有几个进程运行

就绪态：万事俱备，只欠cpu

阻塞态：因为某一事件而暂时不能运行

创建态：进程正在被创建，os为进程分配资源、初始化PCB

终止态：进程正在从系统中撤销，操作系统会回收进程的资源、撤销PCB

转换

![](图片\QQ截图20210602172248.png)

![](图片\QQ截图20210602172408.png)

## 进程控制

通过原语实现进程控制。

执行期间不允许中断，执行前先关中断，执行期间屏蔽外部中断信号，执行后开中断

开关中断权限很大，所以原语必然是在核心态下执行的特权指令

## 进程通信

进程之间存储资源的位置是相互独立的

为了保证进程之间信息交换的安全，操作系统提供一些方法进行进程通信

### 共享存储

给两个进程分配共享的空间，在这个空间内通信。

两个进程的访问是**互斥**的。

基于数据结构：比如共享空间内只能放一个长度为10的数组。速度慢，低级通信方式

基于存储区：在内存中划分出一块共享存储区，**数据形式和存放位置由进程控制而不是操作系统**，速度更快，高级通信方式。

### 管道通信

连接读写进程的共享文件，本质上是在内存中**开辟一个大小固定的缓冲区**。

进程往管道里写入数据，写满后'写'这个进程阻塞，由另一个进程进行'读'进程，管道内的数据读空了，'读'进程阻塞。（各进程访问管道是**互斥**的。并且方向是**单向**的（半双工通信），达到相互读写，需要**两个管道**）

没写满不允许读，没读空不允许写。

读完以后，数据就会被抛弃。

![](图片\QQ截图20210602175958.png)

### 消息传递

数据交换以**格式化信息**为单位，由“发送消息、接收消息”两个原语进行数据交换。
直接通信方式：消息直接挂到接受进程的消息缓冲队列上

间接通信方式：消息先发送到中间实体（信箱）中

![](图片\QQ截图20210602180434.png)

## 线程、多线程

### 定义

每个进程由一个或多个线程组成，**线程是程序执行流的最小单位**

可以理解为轻量级的进程

![](图片\QQ截图20210602192139.png)

由线程id和线程控制块（TCB）组成

### 带来的改变

进程为**资源分配**的基本单位，线程是**调度**的基本单位

进一步提高系统的**并发度**

线程间的并发，如果线程在同一个进程内切换，不需要切换进程环境，**系统开销小**

### 属性

1、线程是处理机**调度**的单位

2、由线程id和线程控制块（TCB）组成

3、也有就绪、阻塞、运行三种基本状态

4、几乎不拥有系统资源，同一进程的不同线程间共享进程的资源

5、同一进程内的线程无需系统干预

6、切换进程的系统开销大，同一进程内的线程间的切换开销小

### 多线程实现

用户级线程：由线程库实现，用户能看见，操作系统看不见

内核级线程：用户和操作系统都看见

**只有内核级线程才是处理机调度的单位**

一般把用户级线程映射到内核级线程上

多对一模型：
![](图片\QQ截图20210602194725.png)

一对一模型（纯内核级线程）：

![](图片\QQ截图20210602194925.png)

多对多模型：

![](图片\QQ截图20210602195045.png)

# 三、处理机调度

## 三层调度

### 高级调度（作业调度）

决定作业由**外存调入内存的顺序**

每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。

只关心调入，调出时作业运行结束才调出。

频率最低

### 中级调度（内存调度）

一些暂时不能运行的进程，我们会把他们暂时调到外存等待（称作**挂起状态**）。

等到可以运行且内存有空闲，再调入回来。

目的：提高内存利用率和系统吞吐量。

注：处于挂起状态时，**PCB不会调到外存，而是常驻内存**，PCB会记录进程在外存中存放的**位置、状态**等信息。被挂起的进程PCB会被放到**挂起队列**

**中级调度决定那个处于挂起状态的进程重新调入内存。**

频率中等

### 低级调度（进程调度）

指进程调度，按某种策略从就绪队列选取一个进程，将处理机分配给他。

频率很高，几十毫秒一次（并发执行） 

#### 调度时机

**主动放弃**

进程正常终止、主动请求阻塞、发生异常

**被动放弃**

时间片完、有更紧急的事情需要处理、优先级更高的进程进入就绪队列

#### 调度方式

非抢占式：只允许进程主动放弃处理机，适合早期批处理系统

抢占式：更重要的进程会抢占处理机，更适合分时、实时操作系统。

### 对比

![](图片\QQ截图20210602202518.png)

## 调度评价指标

cpu利用率 = 忙碌时间/总时间

系统吞吐量=单位时间内完成作业数= 总共完成了多少道作业/总共花了多少时间

周转时间=从作业被提交给系统开始，到作业完成花了多少时间=完成时间-提交时间

平均周转时间=各作业周转时间之和/作业数

带权周转时间=作业周转时间/作业实际运行时间

 等待时间=作业处于等待状态的时间之和

响应时间

## 调度算法

### 先来先服务FCFS

非抢占式

根据到达顺序，先来的进程先服务

优点：公平、简单

缺点：排在长作业后面的短作业需要等待很长时间，对短作业不利 

不会饥饿（长作业得不到服务）

### 短作业优先SJF

有非抢占式的，也有抢占式的（最短剩余时间优先）

当前已经到达的，要求被服务的时间最短的作业优先，时间一样按到达时间优先

优点：平均等待时间、平均周转时间短

缺点：对长作业不利

### 高响应比优先HRRN

非抢占式

响应比=（等待时间+要求服务时间）/ 要求服务时间

不会导致饥饿

### 总结

上面三种交互性糟糕，不关心响应的时间

### 时间片轮转算法RR

抢占式

公平轮流服务，轮流让各个进程执行一个时间片（先让新的进程进就绪队列，再让完成时间片的进程进就绪队列）

用于进程调度

时间片太长，相当于先来先服务，会增大进程响应时间。

时间片太小，系统进程经常切换，开销大

优点：公平，响应快，适合于分时操作系统

缺点：切换开销大，不区分紧急程度

不会饥饿

### 优先级调度算法

可以抢占也可以不抢占

根据优先级高的作业/进程先调度（抢占时被抢占的未完成进程放进队尾，或者新进来的进程之后）

低优先级作业可能饥饿

### 多级反馈队列调度算法

![](图片\QQ截图20210603203638.png)

可以灵活调整对各类进程的偏好程度，CPU密集型进程、I/O密集型进程

### 总结

更注重系统的响应时间、公平性、平衡性，满足交互性系统的需求。

# 四、同步、互斥

## 进程同步、互斥

### 同步

我们希望进程按我们的想法来推进。

同步也称**直接制约关系**，是用来协调进程的工作次序的

### 互斥

一段时间内只允许一个进程访问的资源为**临界资源**，比如打印机、摄像头

访问必须互斥的进行，称为**间接制约关系**

## 互斥的软件实现方法

### 单标志法

每个进程进入临界区的权限只能被另一个进程赋予

![](图片\QQ截图20210604152314.png)

临界区访问的顺序一定是p0->p1->p0->p1....，

假如2处一直不进入临界区，那么p1则一直进不去

违背空闲让进原则

### 双标志先检查法

用bool型变量表示各进程想进入临界区的意愿

![](图片\QQ截图20210604153054.png)

并发执行的时候可能让p0和p1同时访问临界区

违背忙则等待的原则

### 双标志后检查法

![](图片\QQ截图20210604153624.png)

两个进程可能长期无法访问临界资源导致饥饿。

违背空闲让进、有限等待原则

### peterson算法

![](图片\QQ截图20210604154041.png)

遵循了空闲让进、忙则等爱、有限等待的原则

违背让权等待

## 互斥的硬件实现方法

### 中断屏蔽

使用临界资源前，关中断，使用后开中断

优点：简单、高效

缺点：不适用于多处理机；不适合用户进程，只适用于操作系统内核进程（用户没有那么高的权限）

### TestAndSet指令

想检查和上锁用硬件的方式一气呵成，成为原子操作

![](图片\QQ截图20210604155432.png)

### Swap指令

![](图片\QQ截图20210604155716.png)

## 信号量机制

#### 整型信号量

用一个整型变量表示资源的数量

![](图片\QQ截图20210604160419.png)

#### 记录型信号量

![](图片\QQ截图20210604161103.png)

### 实现进程互斥

![](图片\QQ截图20210604162659.png)

### 实现进程同步

设信号量初始值为0

在先要执行的操作后进行V(S)

在后执行的操作前进行P(S)

![](图片\QQ截图20210604163112.png)

### 实现前驱关系

初始化n个信号量

在前驱后V，后续前P

![](图片\QQ截图20210604163849.png)

### 经典问题

#### 生产者-消费者问题

前置条件

![](图片\QQ截图20210604164733.png)

![](图片\QQ截图20210604165132.png)

假如先P(mutex)再P(empty),会造成阻塞，进入死锁状态

互斥的操作要在同步的操作之后

#### 多生产者-多消费者问题

爸爸往盘子里放苹果，妈妈往盘子里放橘子，盘子的容量为1，儿子吃橘子，女儿吃苹果，一次只有一个进程访问盘子。

![](图片\QQ截图20210604170636.png)

由于盘子容量为1，所以可以不设置mutex；但假如容量>1，需要设置mutex

#### 吸烟者问题

单生产者可以生产多个产品，轮流让三个人吸烟。

![](图片\QQ截图20210604182604.png)

#### 读者写者问题

写进程和别的所有进程互斥，但读进程之间不互斥

读进程优先，写进程可能饥饿

![](图片\QQ截图20210604183739.png)

写进程优先

![](图片\QQ截图20210604184216.png)

#### 哲学家进餐问题

假如五个哲学家并发拿筷子，会死锁

![](图片\QQ截图20210604184838.png)

### 管程

信号量机制：编写困难，易出错

引入管程来更方便的实现进程互斥和同步

管程类似于一个类（class）

1、在管程中定义共享数据（比如生产者-消费者问题中的缓冲区）

2、访问共享数据（private）只能通过管程中的入口，即函数。

3、管程中有很多函数，但每次只开放一个入口，只能让一个进程或线程进入。（这种互斥性质由编译器负责，程序员不用关心，因此比信号量机制方便很多）

# 五、死锁

## 定义

各进程相互之间等待对方手里的资源，导致各进程阻塞，无法向前推进（至少由两个进程）

![](图片\QQ截图20210604192530.png)

互斥条件：对必须互斥使用的资源的争抢才会死锁

不剥夺条件：进程获得的资源未在使用完之前，不能有其他进程强行夺走

请求和保持条件：进程已经保持了至少一个资源，又题出新的资源请求，该资源被别的进程占有，自己对已有资源保持不放

循环等待条件：存在资源等待链

## 预防死锁

### 破坏互斥条件

在逻辑上把资源改为可共享的

但很多资源为了系统安全，必须互斥，因此很多时候这个方法无法实现

### 破坏不剥夺条件

比如优先级高的进程可以抢占别的进程的资源

实现起来比较复杂

### 破坏请求和保持条件

静态分配方法：只有在进程所需资源全部满足的时候，才把进程投入使用，并且使用的时候资源独占，并且不请求别的资源

资源利用率低，也会有饥饿的风险

### 破坏循环等待条件

给资源编号，必须按编号递增的顺序请求资源

编程麻烦

## 避免死锁

银行家算法

找到一个安全序列，让所有进程都可以完成，不会死锁

假设达到最大需求前，这些进程不会归还资源

## 检测和解除

图来存关系

检测：

![](图片\QQ截图20210604204120.png)

解除：
1 资源剥夺，把一些死锁进程挂起，抢占他的资源，分配给别的进程

2 终止进程，强行撤销，代价比较大

3 回退一些进程

# 六、内存管理

## 基础知识

![](图片\QQ截图20210606161640.png)

## 管理什么

1、负责内存空间的分配和回收

2、逻辑上对内存空间扩充

3、负责逻辑地址到物理地址的转换

4、内存保护，让进程和进程之间不会相互干扰，实现方式1设置上下限寄存器，2利用重定位寄存起、界地址寄存器判断（重定位寄存器存起始位置，界地址寄存器存相对位置的最大值）

## 覆盖与交换

### 覆盖--同一进程中进行

程序所需内存>实际物理内存

把程序中常用的段常驻内存（放入**固定区**），不常用的在需要时才调入内存（放入**覆盖区**）。

![](\图片\QQ截图20210606164155.png)

**但操作系统不知道程序的覆盖结构，需要程序员来申明，增加负担，不好**

### 交换--不同进程间进行

内存空间紧张时，把内存中的某些进程暂时换出外存（**挂起，PCB常驻内存**），已经具备运行条件的调入内存

1、换到外存的什么地方

外存的对换区，I/O速度较快（与之相对的是文件区）

2、什么时候交换？

内存吃紧的时候（缺页率低的时候）

3、换出什么进程？

尽量换出阻塞的、优先级低的、为了避免饥饿，考虑驻留时间

## 空间分配和回收

### 连续分配

系统为用户分配的空间是连续的

#### **单一连续**

内存分为系统区和用户区，内存中只有一道用户程序

优点：实现简单

缺点：利用率极低

#### **固定分区分配**

用户区划分成若干**固定大小的分区**

分区大小可以相等，可以不相等

建立数据结构记录分区的序号、大小、起始地址、状态

![](图片\QQ截图20210606190955.png)

缺点：会产生内部碎片（指内存某些分配给进程的部分有部分空闲），内存利用率不高

优点：好实现

#### 动态分区分配

不预先划分，再装入内存时动态规划

要用一个数据结构记录每个空闲区域的信息（序号、位置、分区大小、状态）

有**外部碎片**：指的是有些内存部分太小无法使用

**解决**内部碎片：动态**重定位**，把小的部分利用起来

**内外的是进程分配的空间内外**



分配算法：

**首次适应**

每次从上往下找第一个满足要求的分区

**最佳适应**

分区从小到大排，找到第一个满足要求的分区

缺点：会留下很多很小的、难以利用的内存空间，外部碎片很多

**最坏适用算法**

分区从大到小排，找到第一个满足要求的分区

缺点：后来的大进程没有内存分区可用

**邻近适应算法**

 每次从上一次分配的处的空间开始找，到头了就循环回头部，减少排序和查找的开销

### 非连续分配管理方式

连续分配的缺点

固定分区内部碎片大，动态分区外部碎片大

非连续分配管理分配给每个进程分配的空间是离散的、不连续的

#### 基本分页存储管理

##### 定义

把**内存**分成大小相等的**分区**（称为**页框**、内存块、物理块，不能太大，否则内部碎片大），每个页框有一个从0开始的编号

把**进程**分成一个个和页框大小相等的**区域**（称为**页**、页面）

操作系统以页框为单位为进程分配空间，**每一个页面和内存的页框一一对应**，分配的顺序**不一定连续**，**不一定放在相邻的页框**。

![](图片\QQ截图20210606195622.png)

##### 难点

如何实现逻辑地址到物理地址的转换

1、先算逻辑地址在所在页的页号$i$ = 逻辑地址/页面长度

2、找到第$i$页在内存中的页框的起始地址$A$

3、计算出在页内的偏移量$a$

4、物理地址=A+a

为了方便计算页号，我们把页面长度设置为$2^k$

**这样逻辑地址右移k位就是页号i，第k位就是偏移量a**

![](图片\QQ截图20210606201318.png)

同时为了记录每个**页**在内存中对应的**页框**，建立页表，记录映射关系

每个页表项长度相同，页号是 隐含的，隐含在页表初始位置和页表项长度

**初始位置+页表项长度*页号** 就是对应**页框号存储**的位置

![](图片\QQ截图20210606201554.png)

总体流程

假设页框大小（页面大小）为B

逻辑地址，得到页号P和偏移地址W->

判断页号有没有越界P<页表长度M ->

根据页表初始地址F，页号P找到存储页框号的位置=F+页表项长度L*页号P，得到页框号b->

 物理地址=b*B+W=（b+W拼接）

![](图片\QQ截图20210606203214.png)

由于页表也是存在一个页框内的

所以我们希望页表项的长度可以被页框的大小整除

比如页框大小4k，我们可以设置页表项长度为4个字节而不是3个字节

##### 快表

时间局部性：被执行的指令可能不久之后再次被执行

空间局部性：访问某个存储单元，其附近的元素也有可能被访问

把最近使用的页号-页框号存在快表（查询的快很多，不存在内存中，用寄存器存）

假如页框号存在快表中，则只需要访问一次内存，直接访问内存中的数据

假如页框号没存在快表中，则需要访问两次内存，一次访问内存中的页表，一次访问内存中的数据

##### 两级页表

把原来的页表分成几块

![](图片\QQ截图20210607160947.png)

用一个页目录表（用来找页表的某一块的）做一级页号->某一块页表在内存中的位置的映射

![](图片\QQ截图20210607161114.png)

假如页表过大（比一个页面都大），那我们需要建立多级页表来存储

![](图片\QQ截图20210607162402.png)

n级列表访存次数n+1次

#### 基本分段存储管理

##### 定义

把程序按逻辑关系分成几段，每个段有个段名，每段从0开始编址。

把程序分段的放入内存，段内连续，不同段可以不相邻

##### 逻辑地址

逻辑地址结构 = 段号+段内地址

段号决定进程最多可以分成几段，段内地址决定段的最大长度

![](图片\QQ截图20210607164425.png)

##### 段表

把段号映射到物理地址

存段号、段长（因为段长不一样，不像页长是一定的）、内存基址

![](图片\QQ截图20210607164553.png)

查询的时候类似页表查询，多一个检查段内地址是否>段长

![](图片\QQ截图20210607165412.png)

##### 对比分页

![](图片\QQ截图20210607170226.png)

#### 基本段页式管理

##### 分段、分页优缺点

![](图片\QQ截图20210607170813.png)

##### 步骤

先分段，在分页，存入内存的页框内

![](图片\QQ截图20210607171255.png)

每个段都会有一个页表，所以要建立一个表，段号->页表位置

再从页表得到内存块号

![](图片\QQ截图20210607171655.png)

##### 逻辑地址

逻辑地址结构 = 段号+页号+页内偏移量

段号、页号都要判断是否越界

也可以引入快表

![](图片\QQ截图20210607172020.png)

## 虚拟内存

### 传统存储管理方式的缺点

1、一次性：作业必须一次性全部装入内存后才开始运行

2、驻留性：一旦作业被装入内存，就会一直驻留在内存，有些部分其实用不到，就浪费了内存的资源

### 定义和特征

把暂时不需要用的部分留在外存，等到要用的时候再调入内存

最大容量由cpu寻址范围确定，

实际容量=min（外存+内存，cpu寻址范围）

多次性：作业可以分成多次调入内存

对换性：作业运行中允许换入换出

虚拟性：从逻辑上扩充了内存容量，从用户角度看到的内存容量远大于实际容量

### 实现

请求分页存储管理、请求分段存储管理、请求段页式存储管理

思想：访问的信息不在内存时，由操作系统把需要的信息调入内存。内存不够的时候，将内存中暂时不用的信息调出至外存

### 请求分页存储管理

#### 页表

![](图片\QQ截图20210608161905.png)

#### 缺页中断

假如该页不在内存中，会产生缺页中断，操作系统来处理这个中断

缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列

**机制：**

**假如内存中有空闲块，则为进程分配空闲块，把缺少的页面放入该块，修改页表中相应的页表项**

**假如没有空闲块，则会根据算法淘汰一个页面，假如该页面之前修改过，则要写回内存，未修改则不用写回**

####  地址变换

新增步骤：
1、请求调页

2、页面置换

3、修改请求页表中新增的表项

![](图片\QQ截图20210608162928.png)

#### 页面置换算法

##### 最佳置换

淘汰以后永不使用的页面，或者在最长时间内不再被访问的页面

实际无法实现，不可能预判后面访问那些页面

##### 先进先出

淘汰最早进入内存的页面，淘汰队头的页面

实现简单，但性能差

##### 最近最久未使用LRU

淘汰最近最久未使用的页面

需要记录内存中每个页面从上次被访问到现在的时间t

性能好，但实现困难，开销大

##### 时钟置换算法NRU（最近未用算法）

简单实现：
访问某个页面的时候，把访问位设为1。

把内存块连接成循环队列，循环扫描

需要淘汰页面的时候，我们找访问位为0的页面，假如碰到访问位为1的，就把1置为0。假如第一轮扫描结果都是1，再进行下一轮扫描，第二轮一定可以找到

![](图片\QQ截图20210608170419.png)

改进实现：

尽量置换没有被修改过的页面，因为修改过的页面置换后需要写回外存，I/O操作比较慢

（访问位，修改位）

![](图片\QQ截图20210608171029.png)

扫描一轮：原本就有（0,0）

扫描两轮：原本没有（0,0），但是有（0,1）

扫描三轮：原本没有（0,0），（0,1），但是有（1,0）

扫描四轮：原本只有（1,1）

第一优先级是访问位，第二优先级考虑修改位

最多四轮扫描

#### 页面分配策略

驻留集：请求分页存储管理给进程分配的**内存块的集合**，驻留集太大并发度低，驻留集太小缺页率高

固定分配：驻留集大小确定

可变分配：驻留集大小可变

局部置换：缺页时，只能选驻留集内的内存块置换

全局置换：操作系统保留的空闲内存块都可以置换

 ![](图片\QQ截图20210608173207.png)

#### 页面调入时机

1 预调页策略：根据局部性原理，一次调入若干个相邻页面，需要预测不久之后需要的页面，该策略主要用于进程首次调入（**运行前调入**）

2请求调页策略：缺页时才将缺的页调入内存（**运行时调入**），I/O开销大

#### 从何处调入页面

外存的对换区，读写速度比较快

![](图片\QQ截图20210608174002.png)

#### 抖动现象

刚刚换入的页面又要换出外存，刚刚换出的页面又要换入内存

原因：可用的内存块数目<进程频繁访问的页面数目

引入概念

工作集：某段时间内，进程实际访问页面的集合

驻留集要是小于工作集，就会发生抖动，所以要把驻留集设的比工作集大一些

![](图片\QQ截图20210608174624.png)

# 七、文件管理

## 文件的逻辑结构

用户看来，文件内部的数据如何组织

无结构文件：文件内部数据是一系列二进制流或字符流，又称“流式文件”。比如txt

有结构文件：由一组相似的记录组成，每条记录由若干数据项组成，比如.csv文件，数据项长度可以是可变长的、也可以是定长的

### 顺序文件

文件中的记录逻辑上顺序排列，物理上可以顺序存储也可以链式存储

#### 链式存储

用链表存

无法随机存取，只能从链头一个一个往后找

#### 顺序存储

可变长记录，只能从头往后找

定长记录：可以实现随机存取，记录长度为L，第i个记录的位置在i*L

串结构：顺序与关键字无关，无法快速通过关键字找到对应的记录

顺序结构：按关键字顺序排列，可以快速通过关键字找到对应的记录（如折半查找）

### 索引文件

建立索引表，记录第i个记录的指针

![](图片\QQ截图20210608195902.png)

### 索引顺序文件

由于记录很多，那么索引表项可能很大

为了解决这个问题，我们把**文件的记录分成几组**，为每一组对应一个索引表项

![](图片\QQ截图20210608200225.png)

记录过多，建立多级索引，加快查找速度

### 文件目录

####  文件控制块FCB

![](图片\QQ截图20210608201243.png)

### 目录结构

#### 单级目录结构

整个系统只建立一张目录表，文件不能重名

#### 两级目录结构

只有两级目录，分为主文件目录->用户文件目录

不同用户的文件可以重名，单个用户内的文件不能重名

可以设置访问限制

#### 多级目录结构--树形目录结构

不同目录下文件可以重名，但不方便用户之间对文件的共享（一个用户不能访问别的用户的文件）

#### 无环图目录结构

方便多个用户间的文件共享

删除的时候，要记录文件被几个用户共享

当一个用户删除文件，只删除这个用户的目录，别的用户不受影响，除非所有人都删除了这个文件

![](图片\QQ截图20210608202652.png)

#### 索引结构

建立索引表，加快查找效率

## 文件的物理结构（非空闲空间）

### 文件块、磁盘块

外存中文件的逻辑地址也被分成一个一个的文件块

操作系统需要把逻辑块号->映射到物理块号

![](图片\QQ截图20210610191939.png)

### 连续分配

逻辑上相邻的块，在物理上也相邻，每个文件在磁盘上占用**一组连续的块**

记录每个文件在物理上的**起始块号和长度**即可

![](图片\QQ截图20210610192509.png)

优点：可以算出对应的物理块号，支持随机访问；顺序读取的速度快（因为磁盘的访问需要移动磁头，连续的话花费的总时间最短）

缺点：扩展不方便、利用率低、会有磁盘碎片（空闲的区域可能比较分散），

### 链接分配

离散分配，用指针串联

#### 隐式链接

记录起始块号，每一块有一个指向下一块的指针

缺点：只能顺序访问，查找效率低，耗费空间存指针

优点：方便扩展，没碎片

#### 显式链接

目录中只记录起始块

建立一个FAT（文件分配表，常驻内存）记录每一个块号的下一块（显式记录）

优点：可以随机访问，速度快，没有碎片

缺点：FAT占一定的空间

### 索引分配

每一个文件建立索引表：将文件中的各个逻辑块号->映射到物理块号（类似页表）

存索引表的磁盘块叫**索引块**，文件数据存放的磁盘块叫**数据块**

优点：扩展方便、可以随机查找

缺点：文件比较大的时候，一个索引块装不下那么多索引

解决方案：

1、链接方案：分配多个索引块，并把这些索引块链接（隐式，地址转换低效）

2、多级索引：类似多级页表

两级索引文件最大可以是256\*256\*1kb=64mb

![](图片\QQ截图20210610201223.png)

3、混合索引

直接索引（直接指向数据块）、一级间接索引（指向单层索引表）、两级索引混合使用

## 文件存储空间管理（空闲空间）

### 初始划分

为磁盘分区（C盘、D盘）,每个区分为目录区和文件区

![](图片\QQ截图20210610202622.png)

### 空闲表法

记录空闲区间的**起始位置和长度**

可以使用首次适应、最佳适应、最坏适应给文件分配空间

![](图片\QQ截图20210610202827.png)

### 空闲链表法

#### 空闲盘块链

操作系统保存空闲分区的**链头，链尾的指针**

分配：需要k个盘块的时候，从头摘K个盘块，修改链头

回收：回收的盘块依次挂到链尾

![](图片\QQ截图20210610203851.png)

#### 空闲盘区链

操作系统保存空闲分区，**链头，链尾的指针**

每个结点是一段连续的空闲分区

分配：先看有没有哪个结点合适；如果没有就找连续几个结点

回收：需要合并

![](图片\QQ截图20210610203909.png)

### 位示图法

01矩阵存储空闲和已分配信息

需要知道怎么通过字号和位号退出盘块号，反之亦然

![](图片\QQ截图20210610204430.png)

### 成组链接法

大型系统用

![](图片\QQ截图20210610205050.png)

## 文件基本操作

### 创建文件

1、空间大小

2、存放路径

3、文件名

### 删除文件

1、路径

2、文件名

### 打开文件

1、存放路径

2、文件名

3、操作类型（r只读、rw读写）

每个进程打开文件时会建立一个**打开文件表**，存放文件的目录，这样就不用每次都读取目录了。

系统也会有一个打开文件表，整个系统只有一个，记录每个文件被几个进程打开

假如文件被某个进程打开的时候，用户想删除，会被阻止

### 关闭文件

把**打开文件表中的打开计数器-1**

回收资源

### 读文件

指明文件位置、读入数据量、内存位置，从外存读入内存

### 写文件

指明文件位置、写出数据量、内存位置，将文件数据写回外存

## 文件共享

多个用户共享同一个文件，其中一个用户修改文件数据，其他用户也可以看到变化

### 硬链接（基于索引结点）

目录中保存，**文件名->索引结点指针**的信息

索引结点中保存 **文件物理地址**和**计数变量**（计有几个用户同时共享改文件）

![](图片\QQ截图20210611172226.png)

### 软链接（基于符号链）

类似于快捷方式

![](图片\QQ截图20210611172654.png)

## 文件保护

### 口令保护

为每个文件保存一个口令，访问前输入口令才能访问

优点：快、开销小

缺点：保护性弱

### 加密保护

使用密码对文件**加密**，只有输入正确的密码才能解密

比如异或，先用一串二进制串对文件异或，访问时再异或一次才能得到正确的文件

优点：保护性强

缺点：解码花费时间

### 访问控制

在FCB中记录一个访问控制表，记录每个用户对文件可以执行什么操作

也可以把用户划分成几组，每一组的权限不一样，把用户归类就行

## 文件系统的层次结构

![](图片\QQ截图20210611175601.png)

所有知识点串联

![](图片\QQ截图20210611175843.png)

# 八、磁盘

## 磁盘结构

磁盘、磁道、扇区

![](图片\QQ截图20210611182456.png)

## 数据读写

移动磁头到所在扇区的磁道

![](图片\QQ截图20210611182658.png)

真实的硬盘不止一个盘片，每一个盘片都有一个磁头臂

磁头只能共进退

使用(**柱面号、盘面号、扇区号**)定位

![](图片\QQ截图20210611182858.png)

需要花费的时间

1、寻道时间：启动磁头臂、移动磁头所花时间

2、延迟时间：将目标扇区转到磁头下所花时间

3、传输时间：读写数据花费时间

## 磁盘调度算法

目的：减少寻道时间

### 先来先服务

根据请求访问的先后顺序调度

优点：公平，磁道集中的情况下，性能还行

缺点：请求的磁道很分散，性能很差

### 最短寻找时间算法

贪心，只选眼前最优。

优点：性能好，平均 寻道时间短

缺点：可能产生饥饿现象

### 扫描算法

也叫电梯算法

只有移动到最外侧磁道的时候才能往内移动

优点：性能好，不会产生饥饿现象

缺点：1、只有到最边上才改变磁头方向，最后一段有点没必要。

​					当某一方向的请求访问磁道被访问完了，就可以掉头了

​			2、外侧的磁道访问的频率比较高，中间的比较低。

### 循环扫描算法（解决缺点2）

到了末尾直接返回起始端

优点：相比扫描算法，各个磁道响应频率平均

缺点：只有到最边上才改变磁头方向，最后一段有点没必要

### C-LOOK算法

当某一方向的请求访问磁道被访问完了，就可以返回起始端了

## 减少延迟时间

假设我们使逻辑上相邻的扇区在物理上也相邻，则读入使需要读入连续扇区

但是读完一个扇区后，需要一些**传输时间**，而磁盘的**转动是不停**的，这时就需要**多转一圈**，需要很长的延**迟时间**

### 交替编号、错位命名

逻辑上相邻的扇区，在物理上有一些间隔

### 磁盘地址结构的设计

采用

1、（柱面号，盘面号，扇区号）地址编码的时候，可以减少磁头臂的移动次数

2、（盘面号，柱面号，扇区号）地址编码的话，很容易需要更换柱面，导致移动磁头臂

比如地址都是（000,000,000）到（000,001,111）上面的方法可以不用更换柱面，下面需要更换一次

所以把柱面号放在高地址位（因为开销时间大），而盘面号，扇区号放在低地址（开销时间小）

## 磁盘管理

### 初始化

1、低级初始化（物理初始化），各个磁道划分成扇区

2、分区，相邻的柱面组成分区（C盘、D盘）

3、逻辑格式化，建立文件系统。创建根目录、初始化需要的数据结构

![](图片\QQ截图20210612161339.png)

### 引导块

### 坏块管理

无法正常使用的会标记出来

# 九、设备管理

## IO控制器

实现cpu对设备的控制

1、识别cpu的命令

2、向cpu报告设备状态

3、数据交换

4、地址识别

## IO控制方式

程序直接控制、中断驱动、DMA、通道控制

## IO软件层次

![](图片\QQ截图20210612164902.png)

## IO核心子系统

### IO调度

用算法确定一个顺序来处理IO请求，比如磁盘调度

和之前的调度算法差不多

### 设备保护

把设备看做一种特殊的文件，每个设备都有对应的FCB。

为每个用户设置权限，实现设备保护

## 假脱机技术spooling

### 脱机技术

引入脱机技术前：cpu速度和输入设备的速度严重不匹配

使用脱机技术（磁带完成）：把纸带的数据提前写在磁带上，这样就可以和cpu的速度匹配上了

脱机指**脱离主机的控制的输入输出操作**

![](图片\QQ截图20210612170831.png)

假脱机：用软件的方式模拟脱机技术

![](图片\QQ截图20210612171431.png)

举例：共享打印机

为用户进程分配一个逻辑上的打印机

![](图片\QQ截图20210612171831.png)

## 设备的分配和回收

需要考虑：设备的固有属性、分配算法、安全性

数据结构：设备控制表、通道控制表

## 缓冲区管理

类似管道，冲入时缓冲区必须为空；

单缓冲、双缓冲、循环缓冲区、缓冲池



