# 第一讲 向量与线性代数

##  向量

### 基本概念

长度、方向、不随平移而改变

单位向量，用来表示**方向**

向量求和（**几何**上三角形、平行四边形法则，**代数**上坐标相加即可）

#### 点乘

向量->数

$a\cdot b=||a||||b||cos\theta=x_ax_b+y_ay_b+z_az_b$

##### 用处

1计算余弦，得到夹角

2计算投影，把原向量分解成两个垂直的向量

3分析两个向量有多接近

4分析两个向量前与后的信息（b在a的前方还是后方，方向基本一致还是相反）

#### 叉乘 

 $||a\times b||=||a||||b||\sin\theta$

$a\times b=-b\times a$
$$
a\times b=\left(
\begin{aligned}
y_az_b-y_bz_a\\
z_ax_b-x_az_b\\
x_ay_b-y_ax_b
\end{aligned}
\right)
$$

$$
a\times b=A*b=\left(
\begin{aligned}
0\ -z_a\ y_a\\
z_a\ 0\ -x_a\\
-y_a\ x_a\ 0
\end{aligned}
\right)=\left(
\begin{aligned}
x_b\\
y_b\\
z_b
\end{aligned}
\right)
$$



方向和a，b都垂直（右手定则）

##### 用处

1建立三维空间的一个直角坐标系

2判断左和右，结果为正，b在a左侧；反之，b在a的右侧

3判断内和外， 点p是否在三角形中

![](\图片\QQ截图20210330203935.png)

计算$AB\times AP,BC\times BP,CA\times CP$,假如同号，说明在内侧（顺时针、逆时针无所谓）

##### 标准正交坐标系

把向量分解到三个方向上

## 矩阵

### 乘积

$(m\times n)(n\times p)=(m\times p)$

### 性质

1无交换律

2结合律$A(BC)=(AB)C$

3分配律

### 转置

1行列互换

2$(AB)^T=B^TA^T$

3$a\cdot b=a^Tb$

### 单位矩阵

$AA^{-1}=A^{-1}A=I$

$(AB)^{-1}=B^{-1}A^{-1}$ 

# 第二讲 二维变换

$$
\left[\begin{aligned}x'\\y'\end{aligned}\right]=\left[\begin{aligned}a\ b\\c\ d\end{aligned}\right]\left[\begin{aligned}x\\y\end{aligned}\right]
$$



## 缩放

$$
\left[
\begin{aligned}
x'\\y'
\end{aligned}
\right]
=
\left[
\begin{aligned}
s_x\ 0\\0\ s_y
\end{aligned}
\right]
\left[
\begin{aligned}
x\\y
\end{aligned}
\right]
$$

## 对称/反射

$$
y轴对称\left[
\begin{aligned}
x'\\y'
\end{aligned}
\right]
=
\left[
\begin{aligned}
-1\ 0\\0\ 1
\end{aligned}
\right]
\left[
\begin{aligned}
x\\y
\end{aligned}
\right]
$$

## 切变

$$
\left[
\begin{aligned}
x'\\y'
\end{aligned}
\right]
=
\left[
\begin{aligned}
1\ a\\0\ 1
\end{aligned}
\right]
\left[
\begin{aligned}
x\\y
\end{aligned}
\right]
$$

![](\图片\QQ截图20210331093010.png)

## 旋转

默认逆时针，以原点为中心

利用特殊点求解
$$
\left[
\begin{aligned}
x'\\y'
\end{aligned}
\right]
=
\left[
\begin{aligned}
cos\theta&\ &-sin\theta\\sin\theta&\ &cos\theta
\end{aligned}
\right]
\left[
\begin{aligned}
x\\y
\end{aligned}
\right]
$$

**特殊性质：**旋转矩阵是正交矩阵，$R^{-1}=R^T$

## 齐次坐标

平移操作不太好写，所以引出齐次坐标
$$
\left[
\begin{aligned}
x'\\
y'\\
w'
\end{aligned}
\right]=
\left[
\begin{aligned}
1\ 0\ t_x
\\0\ 1\ t_y
\\0\ 0\ 1
\end{aligned}
\right]
\left[
\begin{aligned}
x
\\y
\\1
\end{aligned}
\right]=
\left[
\begin{aligned}
x+t_x
\\y+t_y
\\1
\end{aligned}
\right]
$$
一般操作
$$
\left[
\begin{aligned}
x'\\
y'\\
1
\end{aligned}
\right]=
\left[
\begin{aligned}
a\ b\ t_x
\\c\ d\ t_y
\\0\ 0\ 1
\end{aligned}
\right]
\left[
\begin{aligned}
x
\\y
\\1
\end{aligned}
\right]
$$


二维点$(x,y,1)^T$

二维向量$(x,y,0)^T$

向量+向量=向量

点-点=向量

点+向量=向量

点+点=这两个点的中点

因为
$$
\left[
\begin{aligned}
x
\\y
\\w
\end{aligned}
\right]是二维点
\left[
\begin{aligned}
x/w
\\y/w
\\1
\end{aligned}
\right]
$$

## 逆变换

$M^{-1}$

## 矩阵组合

将变换矩阵相乘，用一个矩阵实现一系列操作

## 矩阵分解

比如，绕任意点c旋转，先把图平移到原点，再旋转一个角度，在平移回去

# 第三讲 变换2.0

## 三维变换

三维点$(x,y,z,1)^T$

三维向量$(x,y,z,0)^T$
$$
\left[
\begin{aligned}
x'\\
y'\\
z'\\
1
\end{aligned}
\right]=
\left[
\begin{aligned}
a\ b\ c\ t_x
\\d\ e\ f\ t_y
\\g\ h\ i\ t_z
\\0\ 0\ 0\ 1
\end{aligned}
\right]
\left[
\begin{aligned}
x
\\y
\\z
\\1
\end{aligned}
\right]
$$
先线性变换，再平移

## 绕轴旋转

![](\图片\QQ截图20210401100251.png)

## 一般旋转

罗德里格斯旋转方程

假设绕n轴（默认过原点），旋转$\alpha$角

旋转方程为，假如不过原点，先平移->再旋转->平移

![](\图片\QQ截图20210401101204.png)

## 观测变换

### 视图/摄像机变换

#### 相机定义

1 位置(position)      $\overrightarrow{e}$

2 目视方向(look_at/gaze direction)     $\hat{g}$

3 向上方向(up direction)     $\hat{t}$

让物体和相机一起变换

默认相机永远在1原点 2 向上方向为Y 3目视-Z  

相机做了一些变换，则将他变换$M_{view}$回默认位置，这时别的物体再和相机一起做$M_{view}$变换

#### 转移方法

$M_{view}=R_{view}T_{view}$

先平移e到原点

![](\图片\QQ截图20210401103815.png)

旋转g到-Z，旋转t到Y，X就自然对上了（但写起来很麻烦）

所以反过来考虑，先把X到$(g\times t)$,再把Y到t,Z到-g，原来的变换就是这个变换的逆变换。

![](\图片\QQ截图20210401103837.png)

为什么求转置就可以得到逆呢？因为旋转矩阵是正交矩阵，转置==逆

### 投影变换

![](\图片\QQ截图20210401105649.png)

#### 正交投影（没有近大远小）

认为摄像机在无限远

##### **一种简单的投影方式**

把物体的Z坐标去掉，就可以到得到在$XOY$上的投影了

再进行平移和缩放，让投影落在$[-1,1]^2$中（方便后面的计算）

![](\图片\QQ截图20210401110013.png)

##### **一般方法**

![](\图片\QQ截图20210401110524.png)

1定义立方体的左l、右r、下b、上t、远f、近n（l<r,b<t,f<n(因为是在-z方向上的)）opengl使用左手系也是这个原因

2转换为**标准立方体**

先平移，再缩放

![](\图片\QQ截图20210401110844.png)

#### 透视投影（存在近大远小）

##### 性质

平行线会相交与一点

##### 先验知识


$$
\left[
\begin{aligned}
x
\\y
\\z
\\w
\end{aligned}
\right]是三维点
\left[
\begin{aligned}
x/w
\\y/w
\\z/w
\\1
\end{aligned}
\right](w\neq0)
$$
#####  步骤

![](\图片\QQ截图20210401112810.png)

1把椎体‘挤压’成长方体 

近平面（n面）不变

远面（f面）Z值不变，远面中心不变

![](\图片\QQ截图20210401190634.png)

相似三角形求$y'=\frac{n}{z}y,x'=\frac{n}{z}x$

 ![](\图片\QQ截图20210401191120.png)

得到挤压后的点，可以算出一部分变换矩阵

![](\图片\QQ截图20210401191216.png)

根据近平面（n面）上的点不变，则点（x,y,n,1）不变，可以得到下面的推导，得到第一个方程$An+B=n^2$

![](\图片\QQ截图20210401191707.png)

![](\图片\QQ截图20210401191807.png)

根据远面z值不变，可以得到第二个方程,$Af+B=f^2$

![](\图片\QQ截图20210401192249.png)

得到$A=n+f,B=-nf$,矩阵完成，挤压完成。

2做正交投影

3得到投影

# 第四讲 光栅化（三角形）

## 需要定义的东西

1 画面的**长宽比** **aspect**

2 垂直可视角度（vertical field of view,fovY）

![](\图片\QQ截图20210401194808.png)

## MVP之后做什么？

M，模型变换，即摆放模型

V，视图变换，即摆放相机

P，投影，得到一个$[-1,1]^3$的标准立方体

把立方体放在**屏幕**上

## 屏幕

### 定义

1 二维数组，由**像素**（pixel）组成

2 一种典型的**光栅**（raster==德语的屏幕，rasterize==把东西画在屏幕上）成像设备

### 定义屏幕空间

1 像素坐标为(x,y),x,y整数，从(0,0)到(width-1,height-1),像素中心在(x+0.5,y+0.5)

2 屏幕覆盖范围(0,0)到(width,height)

![](\图片\QQ截图20210401195800.png)

#### 让立方体在屏幕空间中显示

使用如下方程即可（视口变换）

![](\图片\QQ截图20210401200321.png)

## 将三角形光栅化成像素

### 为什么是三角形？

1 三角形是最基础的多边形2 别的多边形都可以拆解为三角形3 一定在一个平面内4 方便定义内外5 方便内部根据三个顶点渐变

### **步骤**

1判断像素的中心点是否在三角形内

（1）采样（sampling）

​		  对每一个点进行判断（也可以以三角形的上下左右界做一个长方形，只判断这里面的点），计算函数值（比如在三角形内为1，不在为0）

​		  判断函数实现：

​		  做叉积，判断是否同号，正好在边上，可以算也可以不算

2在内的让像素点亮起 

# 第五讲 光栅化（反走样）

## 反走样anti-aliasing（一种简单的抗锯齿MSAA multi sampling anti aliasing）

### 走样的类型

1锯齿2摩尔纹3车轮效应...

### 走样的原因

信号太快，但采样比较慢

### 解释

先验知识：1傅里叶级数展开，任何周期函数都可以用sin，cos和一个常数的线性组和表示

​					 2傅里叶变换，将一个信号分解成许多频率的段

![](\图片\QQ截图20210402140028.png)

不难发现，频率越高，采样结果越差

![](\图片\QQ截图20210402140317.png)

高频率信息往往在图像中的边界（或者说是一些轮廓），因为这些边界处会发生很大的偏差，所以频率很高

### 反走样方法

#### 方法一

增加采样率，买一块高分辨率屏幕，但并不实用

#### 方法二

先得到一个模糊（滤波filering，去掉一些频率）的三角形，在判断像素点是否在模糊的三角形内（步骤不能反）

 ![](\图片\QQ截图20210402145136.png)

滤波=卷积（=平均）

卷积可以简单理解为，把一个信号和它周围的信号取一个加权平均，来代替这个信号，就做到了模糊

![](\图片\QQ截图20210402142243.png)

并且有，时域上的卷积=频域上的乘积，频域上的卷积=时域上的乘积

![](\图片\QQ截图20210402142632.png)

滤波器（低通滤波，即只让低频通过），即那个3x3的矩阵

滤波器越大，频域上覆盖的越小（因为模糊的范围变大了，假如大到比图片还大，那就都一个颜色了）

滤波器越小，频域上覆盖的越大（假如只有一个，那就没有过滤了）

采样（在频域上）=重复原始信号的频谱

a*c=e,所以b卷积d=f

![](\图片\QQ截图20210402143938.png)

采样率低的时候，重复频谱会重叠，造成走样，所以当我们过滤掉高频的信号，就可以防止堆叠（如下图，假如不过滤高频，下方就会重叠了）

![](\图片\QQ截图20210402144939.png)

##### 具体操作

1 对每一个像素做一个卷积（做一个平均），对每一个像素的覆盖面积（像素值）求一个平均

![](\图片\QQ截图20210402145559.png)

但这个计算比较麻烦，所以我们采用超级采样（supersampling）

把一个像素分解成4x4个像素，判断每一个小点是否在三角形中，再平均，就可以得到近似值，这个平均值就是最终的像素颜色。

可以理解为后一步的采用，在这一步模糊的同时其实已经做了，

2 然后对每一个像素采样

显然，**这种方法带来了很大的计算量**

其他的方法，FXAA（先得到一个有锯齿的图，再把锯齿去除），TAA（复用上一帧的画面）...

# 第六讲 着色（shading）

## 可见性、遮挡

### 油画家算法

先画最远的，再画最近的

由于要排序，所以复杂度是O(nlogn)的

### z-buffering 深度缓存算法

算法思想：**始终维护最小的z值** 

每一个三角形的计算是常数级别的，所以复杂度为O(n)

需要存储的信息

1 frame buffer存储颜色的值

2 depth buffer存储深度的值

为了简便，z值为正，z小则近，z大则远

## 着色

### 定义

1 shading point （着色点，物体表面的一个点）

2 法线 n

3 观测方向 v

4 光照方向  l

5 表面参数（颜色，亮度）

6 不考虑影子，只考虑着色本身

7 光的强度 $I=I/r^2$

### Blin-Phong反射模型

#### 步骤

##### 1 漫反射Lambertian（diffuse）shading

计算漫反射后光的能量，max是因为假如cos为负数，则没有光射过来，$n\cdot l$都是单位长度，所以直接得到cos

![](\图片\QQ截图20210402165632.png)

#####  2 高光

h为l和v的角平分线，n和h越接近，则v和l的反射角越接近（blin-Phong的改进，这样比算反射角和v的夹角（Phong反射模型）好算）

p（100~200）的次方是因为$cos\theta$的值比较大，直接用会导致高光过大

![](\图片\QQ截图20210403091156.png)

##### 3 环境光照（不被光源直接照射，但是会被环境中的漫反射照亮）

从各个方向来，所以和v，n都没有关系，是一个常数

实际上只是个假设，并不是真实的

![](\图片\QQ截图20210403093206.png)

### 着色频率

#### flat shading

着色每一个三角形（flat shading），认为一个三角形是一个shading point，两条边做叉积得出法线（对于平滑平面效果不好，三角形内部没有颜色过渡）

#### Gouraud shading

对于每一个顶点求法线着色（Gouraud shading）

每一个顶点都是周围许多三角形共用的一个顶点，那么这个顶点的法线，就是这些面的法线的平均（加权平均，按三角形面积）

![](\图片\QQ截图20210403101311.png)

#### Phong shading

对三角形每一个顶点做法线，对于每一个像素点插值、计算、着色（不是Blin-Phong 反射模型），

### 图形管线（实时渲染管线）

变换->投影->光栅化（是否在三角形内，是否可见）->着色

![](\图片\QQ截图20210403102139.png)

### shader

设计顶点/像素如何着色的代码

vertex shader

pixel/fragment shader

### 纹理映射

#### 定义

纹理就是三维物体上展开的一个小的二维平面

每一个纹理我们定义一个坐标，u，v的范围（0,1）

![](\图片\QQ截图20210403105244.png)

#### 插值--重心坐标

##### 目的

做三角形内部的**插值**，在三角形内部平滑过渡

##### 插什么值

纹理坐标、颜色、法线

##### 定义

对于一个三角形内部的点$(x,y)=\alpha A+\beta B+\gamma C,\alpha+\beta+\gamma=1，\alpha,\beta,\gamma\ge0$,可以这么表示，那么我们可以用$(\alpha,\beta,\gamma)$表示这个点,即这个点的重心坐标

##### **重心**

$(x,y)=\frac{1}{3}\alpha+\frac{1}{3}\beta+\frac{1}{3}\gamma$,把三角形分成三个等面积的三角形

也可以用面积来表示

![](\图片\QQ截图20210403113204.png)

![](\图片\QQ截图20210403114305.png)

##### 插值方法

用这三个系数去和三角形三个顶点的属性做线性组合，$V=\alpha V_A+\beta V_B+\gamma V_C$,v可以是坐标、纹理坐标、颜色、法线、深度、材质属性...

##### 坏处

投影后会改变，所以三维的需要先插值，再投影

### 应用纹理

#### 方法

使用纹理坐标，应用到对应的采样坐标上即可

#### 带来的问题

##### **假如纹理太小了**，显示出来的效果会不清晰（Bilinear双线性插值）

解决办法：**Bilinear双线性插值**（质量一般）

对于一个非整型的坐标，如何给他一些值，让过渡更平滑呢？

我们参考它附近的四个点，做两次线性插值，根据s，t的大小决定值的大小更接近哪个像素

![](\图片\QQ截图20210403120403.png)

办法二：**Bicubic**（取周围十六个，做三次的插值），运算量大

##### **纹理太大了** 会走样 （mipmap、各向异性过滤  ）

近处一个像素覆盖的纹理较小，远处一个像素会覆盖大量的纹理

![](\图片\QQ截图20210403121637.png)

超采样，可以解决问题，但是开销太大了

解决方法：**mipmap**（快速，近似，正方形的范围查询）

1每次将边长/2，最终存储量为$1+\frac{1}{4}+\frac{1}{16}+...=\frac{4}{3}$,存储量只多了$\frac{1}{3}$

![](\图片\QQ截图20210403123058.png)

2找到某个像素点对应的纹理范围（近似）

方法是找到周围三个点（如图所示）对应的纹理坐标，确定一个L（一般是最长的那个距离，如图），再以像素点对应的纹理坐标为中心，边长为L的正方形为所得范围

![](\图片\QQ截图20210403124516.png)

 3查询这个范围的平均值

根据范围的大小，直接去查那张图（第$D=\log_{2}L$张图）的位置的值就好了，但是得到的结果比较**离散**

可以对层与层之间做三线性插值，这样就可以得到连续的值了

分别在D、D+1层做双线性插值，再对他们两个做线性插值

![](C:\Users\11634\Desktop\课程学习\图形学\图片\QQ截图20210403125617.png)

4 结果会比较糊

![](\图片\QQ截图20210403130038.png)

因为取得对应的材质范围是正方形，而一般情况很可能不是正方形，而是不规则的

![](\图片\QQ截图20210403130805.png)

解决办法，**各项异性过滤**

mipmap里存储的都是边长都除2的图片，这里我们也存储只缩小长/宽的图片ripmap，

这样就可以解决一部分长方形的范围了，代价为开销为原来的3倍

但是比较奇怪的，比如最上面的斜长条形，依然不能解决

解决办法有EWA过滤，开销就更大了

#### 具体应用

##### 环境光照 environment map

用纹理反映环境光（球形环境光，可是展开物体会扭曲）

![](\图片\QQ截图20210403210626.png)

##### 凹凸贴图bump mapping

在不把几何形体变复杂的情况下，定义一个复杂纹理，来显示出凹凸的效果

对于一些映射来的纹理，定义一个假的法向量，从而欺骗shader，画上一些较暗的部分，达到凹凸的效果

**步骤**

1 不给原来的每个三角形增加额外的细节

2 给每个像素增加扰动（height shift）

3 怎么修改法向量？

对于二维

![](\图片\QQ截图20210404093018.png)

对于三维，分别计算u方向和v方向的切线

对于一般情况，p法向量可能不朝向(0,0,1),所以需要定义一个**局部的坐标系**，使p的法向量始终朝向(0,0,1)

![](\图片\QQ截图20210404093308.png)

##### 位移贴图 displacement mapping

把顶点位置移动了，要求三角形够细 

凹凸贴图只是改变法线方向，欺骗人的眼睛，实际的几何形体没有变，所以在边缘和阴影处会露馅

![](\图片\QQ截图20210404095533.png)

##### 三维纹理

# 第七讲 几何

## 隐式表示 implicit

### 定义方法

**1 满足某种关系的点的集合**，比如圆$x^2+y^2+z^2=1$,或者其他的方程$f(x,y,z)=1$

**2 通过布尔运算组合几何形体**

![](\图片\QQ截图20210404105145.png)

**3 距离函数**

比如，等高线

表示点到边界的最短距离

![](\图片\QQ截图20210404110411.png)

**4分形表示**

有点像递归

![](\图片\QQ截图20210404111234.png)

### 问题

采样的时候比较困难，比较难找到所有的点，也很难看出他是什么样的。

### 好处

方便判断点是否在面上

## 显式表示 explicit

### 方法

1 **点云**，用表面上的点来表示，一系列点的集合

表示简单，但需要特别多的点

2 **多边形面（polygon mesh ）用的最多**

通过存储多边形（通常是三角形或四边形）来表示面

方便处理、采样等。

比点云会带来更复杂的数据结构

举例   **.obj文件**

左上为点，右上为法线，左下为纹理坐标，右下为连接方法，格式为 **点的索引/纹理坐标索引/法线索引**

![](\图片\QQ截图20210405100030.png)



**3 参数映射**

![](\图片\QQ截图20210404104445.png)

### 问题

不好判断点相对面在哪

### 贝塞尔曲线（Bezier curves）

#### 定义

用一些控制点定义曲线

起点为$p_0$，终点为$p_3$，一开始的曲线与$p_0p_1$相切，后来的曲线和$p_2p_3$相切，除了起始点，其他点不一定要经过

![](\图片\QQ截图20210405101110.png)

#### **绘制方法**

##### **de Casteljau Algorithm** 

考虑只有三个点的情况（quadratic Bezier）

假设从$b_0到b_1，b_1到b_2$需要一个单位时间，初始点出时间设为0，终点处为1，那我们把0到1上对应的曲线的点画出来即可

比如说要找$t=\frac{1}{3}$时的点

那么先找到$\frac{1}{3}b_0b_1$处的点，和$\frac{1}{3}b_1b_2$处的点，把两个点连起来，得到的直线的$\frac{1}{3}$处为所得

四个点的话，就是一个**递归**的过程

![](\图片\QQ截图20210405101630.png)

##### 代数公式

三个点

![](\图片\QQ截图20210405102743.png)

 n个点

![](\图片\QQ截图20210405103005.png)

系数$B_i^n(t)=C_n^it^i(1-t)^{n-i}$为伯恩斯坦多项式



![](\图片\QQ截图20210405103054.png)

#### **好处**

1 方便做仿射变换，想找仿射变换后的曲线，可以把控制点变换后，再计算曲线即可

仿射变换指的是二维坐标到二维坐标的变换，所以投影变换不行

2 凸包性质

贝赛尔曲线一定在控制点的凸包内

凸包：包围平面上所有点的凸多边形

### 逐段贝赛尔曲线（piecewise Bezier）

高阶的贝塞尔曲线可能会变得平滑

![](\图片\QQ截图20210405104628.png)

因此人们往往会每**四个**控制点画一个贝塞尔曲线

如何保证曲线是光滑的呢？

当某一个点即为前一个曲线的终点，也为下个曲线的起点，形成两个切线要共线且方向正好相反且大小也要一样（导数连续）

![](\图片\QQ截图20210405105249.png)

$c_0$连续，$a_n=b_0$，a为前一段的点，b为后一段的点

$c_1$连续，$a_n=b_0=\frac{1}{2}(a_{n-1}+b_1)$

### 贝塞尔曲面

有点像二次插值

先找一些点，画成一些曲线，再用曲线上各自的点，在做一系列的贝塞尔曲线，得到曲面

![](\图片\QQ截图20210405111019.png)

### 曲面细分mesh subdivision

使用更多的三角形，使原来的形体有所变化，模型变得更加光滑

![](\图片\QQ截图20210405113215.png)

#### Loop Subdivision（Loop是人名，不是循环）只能用于三角形面

##### 步骤

1 把一个三角形分成四个三角形

2 调整三角形位置，先区分新的顶点和旧的顶点，再根据权重来调整点的位置，新旧不一样

##### 举例

对于**新**的顶点，往往是在两个三角形共享的边上的，比如图中的白点，做如下更新

![](\图片\QQ截图20210405113924.png)

对于**旧**的顶点，n为顶点的度，一部分保留原有位置信息，再加上周围的点

![](\图片\QQ截图20210405114306.png)

![](\图片\QQ截图20210405113637.png)

#### Catmull-Clark Subdivision用于各个面

##### 定义一些概念

1 noun-quad face 非四边形面

2 extraordinary vertex 奇异点,读不为4的点 

![](\图片\QQ截图20210405115302.png)

##### 步骤

1 每个面中取一点（可以是重心，也可以是其他的）

2 每条边都取中点

3 把新的点都连起来（一个面的内部的连起来）

![](\图片\QQ截图20210405115329.png)

可以发现一次细分后

奇异点增加了2（即原来非四边形个数）

度数上，原本的奇异点度数不变，新的点的度数为那个非四边形的边数

非四边形面个数为0，都消失了

**相当于原来的非四边形都转换成奇异点了，在做一次细分，奇异点数不会增加**

4 把点分成三类，（1）新的点中，在面中间的点（2）新的点中，在边中间的点（3）旧的点，分别更新

![](\图片\QQ截图20210405120310.png)

### 曲面简化 mesh simplification

为了提升性能，减少三角形数量，简化模型

![](\图片\QQ截图20210405120925.png)

#### 方法 边坍缩 edge collapsing

##### **二次误差度量 Quadric Error Metrics** 

如何让下图的蓝色三角形可以描述灰色五边形的轮廓？

假如第三个点取五个点或者上面三个点的平均，会显得有些扁

二次误差就是找一点，**这个点和原来的五个点的距离的平方和最小**

![](\图片\QQ截图20210405121615.png)

#### **步骤**

贪心算法

1 对模型中所有的边，都假设如果坍缩这个边，计算会带来多少的误差

2 从小到大排序

3 从小的开始一次坍缩

#### **问题**

1 坍缩一条边，会影响其他的边，其他的边又得再算一次

所以我们需要有一个数据结构，可以得到最小值，之后还要更新一些边，所以需要**堆**

# 第八讲 光线追踪

## 应用

离线的画面渲染，比如动画片

## 定义

光线：

1 沿直线传播（只是假设）

2 光和光之间不会碰撞（只是假设）

3 光是从光源出发，最后到达人眼（可逆的，光追事实上也是这么做的）

## 光栅化方法形成阴影shadow mapping（不是光追）

### 解释

假如摄像机，可以看到这点，但从光源处看不到这个点，那么这个点在阴影处

### 操作

1 从光源处看场景，对场景做投影，记录看到的点的深度

2 从相机处看场景，计算这个点在光源处看时的位置，和实际到光源的深度

3 一致的话，就可以从光源看到，深度大的话就看不到，被物体挡住了

### 问题

1 浮点数计算相等很困难

2 阴影信息走样

3 当光线反射不止一次时很麻烦

4 磨砂表面的反射

5理论上只能做硬阴影（边缘非常锐利）

![](\图片\QQ截图20210405140425.png)

光源有一定大小会产生软阴影，图中的penumbra（半影就是一个例子）

![](\图片\QQ截图20210405140745.png)

....

### 应用

1 早期动画

2 很多3d游戏（塞尔达、马里奥奥德赛）

3 实时画面运用的多

## Whitted-Style Ray Tracing（递归算法）

### 方法

**模拟光线弹射**

1 设定primary ray，即人眼出去的第一道光线 

2 将碰到的点和光源相连

3 再将primary折射、反射，和别的物体交的点和光源相连

4 判断这些点是否可见（和光源中间是否有遮挡）

5 计算光线传播中的能量损失，在第一个点处加权平均可以得到这个点的光照情况，就可以着色了

![](\图片\QQ截图20210405155406.png)

### 实际操作

光线：定义好起点的射线，由一个点o和方向向量d来表示

光线上任意一点：$r(t)=o+td,-\le t<\infty$

#### 1 求像素对应的场景坐标

要缩放这些坐标，把他们还原到光栅化之前的位置

#### **2 求交点**

##### **和球（点即在球上，又在线上）**

![](\图片\QQ截图20210405160541.png)

解满足t>0，且等式有解，且相交或相切

##### **和一般隐式表示的物体求交**

解方程即可，可以用来判断点是否在物体内，假如点在物体内，可以得到奇数个交点，点在物体外，会得到偶数个交点

![](\图片\QQ截图20210405160842.png)

##### **和三角形求交**

对于每一个三角形来说：

###### 方法一

可以求三角形所在**平面和光线**的交点，再判断**交点在不在三角形内**

首先要定义这个平面，需要一个法线和平面上的一个点

![](\图片\QQ截图20210405162311.png)

 

###### 方法二Moller Trumbore算法

假如光线在三角形内有交点，则这个点一定可以写成重心坐标 形式，解出来即可

b1>=0, b2>=0,t>=0,  b1+b2<=1

则满足条件

![](\图片\QQ截图20210405162442.png)

### 问题

假如用光线和物体上每个三角形求交，可以得到结果，但很**慢**

### 加速方法

#### **包围盒**（把物体完全包围的几何体）

##### 原理

假如光线不能进入包围盒，则不可能到达里面的物体上

##### 操作

通常使用轴对齐包围盒AABB

![](\图片\QQ截图20210405164054.png)

##### 定义一个包围盒

用两个点pMin,pMax

##### 如何判定和包围合的是否交：

先考虑二维：

求出和$x=x_0,x_1$的交点时的t，分别为$t_{min},t_{max}$

求出$y=y_0,y_1$的交点时的t，分别为$t_{min},t_{max}$

假如两个区间有重合即$t_{enter} = max\{t_{min}\},t_{exit}=min\{t_{max}\},t_{enter}<t_{exit}$，则光线经过这个正方形

假如$t_{exit}<0 $说明盒子在光源后面，则不存在交点

假如$t_{exit}\ge0,t_{enter}<0$,光源在盒子里面，肯定有交点

![](\图片\QQ截图20210405164544.png)

三维的情况和二维类似，只是求和对面的交点时的t，再求交

假如两个区间有重合即$t_{enter} = max\{t_{min}\},t_{exit}=min\{t_{max}\},t_{enter}<t_{exit}且t_{exit}\ge0$，则光线经过这个正方形

这时求交就不需要严格地求和平面的交点了，可以找一个面，只关心x轴方向上的分量

比如求$t_{minx} = (pMin.x-o.x)/d.x$

![](\图片\QQ截图20210405170642.png)

#### **均匀网格  uniform grids**

由于格子求交，比物体求交快

（1）把整个场景分成一个个的小格子

（2）判断光线是否和物体所在的盒子相交

（3）再去判断是否和物体是否有交点

在均匀分布的场景中比较适用

但在复杂场景中就不适用了

#### **空间划分 spatial partitions（KD-Tree）**

（1）八叉树 （用的不多）

把空间切两刀，分成八块，给定一个标准（比如这个子空间里已经不和任何物体交了），让某些子空间继续划分，某些停止划分

（2）**KD-Tree** （保留了二叉树的性质，不像八叉树纬度高的时候分叉太多）

##### **步骤**

每次只砍一刀

二维情况，第一层水平划分，下一层垂直划分，交替进行

三维情况，第一层沿x轴划分，下一层沿y轴划分，下一层沿z轴划分，交替进行

![](\图片\QQ截图20210406111528.png)

##### **存储的数据**

**中间节点**

1 沿哪个轴切的

2 切的位置

3 子节点的指针

4 中间节点不存储物体

**叶子节点**

1 一些物体

##### **具体步骤**

分别判断和这些叶子节点的盒子是否有交点，有的话在和内部的物体求交

![](\图片\QQ截图20210406112330.png)

##### 难点

1 怎么判断划分出的格子，和实际物体相交，因此该方法最近几年用的不多

2 一个物体可能在多个格子里，很麻烦

（3）BSP-Tree

每次选择一个方向砍一刀，与kd-tree不同于kd-tree总沿水平/垂直的方向砍一刀

但是计算太复杂，维度高时太复杂

#### 物体划分 object partitions(BVH)

**Bounding Volume Hierarchy（BVH）**使用广泛

##### **基本方法**

1 用盒子把场景包围

2 把三角形分成两部分，再分别求包围盒，然后继续划分，直到达到某个标准，比如每个盒子里只有5个三角形（保证一个物体只在一个盒子里），当然也要尽可能让包围盒的重叠少一些

3 把实际物体记录在叶子节点里

![](\图片\QQ截图20210406135103.png)

##### 实际操作

1 如何划分节点？

（1）选择最长的轴来切，比如x的跨度比较大，那就竖直x轴切分

（2）取中间的物体来划分（快速选择算法O(n)，找无序数中第i大的数），树更加平衡

2 递归找出距离眼睛最小的交点，当父节点已经不相交就可以剪枝了

##### 数据结构

**中间节点**

（1）包围盒（2）子节点指针

**叶子节点**

（1）包围盒（2）物体列表

## 辐射度量学radiometry

### 学习原因

1 比如光的强度（light intensity）为10，10代表什么呢？

2 whitted style 光线追踪不真实

3 为了**精确**描述光照

### 概念

Radiant energy（辐射能）:电磁辐射的能量，用符号Q[J=Joule]表示

Radiant flux（辐射通量）:单位时间的能量，功率$\Phi=\frac{dQ}{dt}[W=Watt][lm = lumen]^*$瓦特/流明

Radiant Intensity（辐射强度）：单位**立体角**的能量，$I(\omega)=\frac{d\Phi}{d\omega}[\frac{W}{sr}][\frac{lm}{sr}=cd]$

solid angles（立体角）：平面上的角度为$\theta=\frac{l}{r}=\frac{弧长}{半径}$

​				  立体角为$\Omega = \frac{A}{r^2}=\frac{球上一块的面积}{半径平方}，整个球立体角为4\pi$

differential solid angles（单位(微分)立体角）：$d\omega=\frac{dA}{r^2}=sin\theta d\theta d\phi$

![](\图片\QQ截图20210406143425.png)

Irradiance（辐照度）:单位面积的能量 (面和光线垂直，即投影面积上),$E(X) = \frac{d\Phi(X)}{dA}[\frac{W}{m^2}][\frac{lm}{m^2}=lux]$

radiance（光谱辐射）：单位立体角并在单位面积内的能量$L(p,\omega)=\frac{d^2\Phi(p,\omega)}{d\omega dAcos\theta}$

当理解为单位立体角内的Irradiance，方便理解某个面接受的能量

![](\图片\QQ截图20210406213653.png)

当理解为单位面积内的Intensity，方便理解发出去的能量

![](\图片\QQ截图20210406213916.png)

Irradiance可以理解为从dA面积上接受的能量

Radiance可以理解为面积dA从方向$d\omega$接受的能量

![](\图片\QQ截图20210407084454.png)

### BRDF（bidirectional reflectance distribution function 双向反射传播函数）

#### 如何理解反射

某一点接受各个方向来的Irradiance（能量），再把它发射到四面八方（分配到各个立体角上）

![](\图片\QQ截图20210407085149.png)

#### 功能

计算从dA发射到各个角度的能量，定义**如何分配这些能量**

![](\图片\QQ截图20210407085454.png)

把所有入射的方向都计算一次，加起来（积分）就可以得到结果

![](\图片\QQ截图20210407090208.png)

#### 困难

不只是光源可以到达点p，其他物体反射的光也可以到达，需要递归求解，比较麻烦

### 渲染方程 rendering equation

假如物体本身会发光，那么BRDF需要加一个自身的光

假如有很多**点光源**，**加**起来就好，**面光源积分**即可

![](\图片\QQ截图20210407090725.png)

**其他物体反射光，就把其他物体当成光源，递归定义**

![](\图片\QQ截图20210407091709.png)

简化形式

![](\图片\QQ截图20210407091923.png)

把L分解，写成展开形式

![](\图片\QQ截图20210407092226.png)

分解成自身的光，弹射一次的光（直接光照），弹射两次的光，弹射三次的光（间接光照）...

![](\图片\QQ截图20210407092259.png)

#### 全局光照

光栅化只能告诉我们前两项，后面做起来比较麻烦，把后面也做了就是全局光照

最后会收敛到某一个亮度

![](\图片\QQ截图20210407092721.png)

## 蒙特卡洛路径追踪

### 概率论回顾

随机变量x

期望$E(X)=\sum\limits_{i=0}^{n}x_ip_i=\int_{-\infty}^{+\infty}xf(x)dx$

Y = h(x)

$E(Y)=\int_{-\infty}^{+\infty}h(x)f(x)dx$

概率密度f

概率分布$F(x)=\int_{-\infty}^{+\infty}f(x)dx$

### 蒙特卡洛积分

#### 用处

计算一个复杂函数（不好求不定积分，不好积）的**定**积分

![](\图片\QQ截图20210407195727.png)

#### 方法

在积分域内不断取f(x)，假设整个区域内为长度为b-a，高度为f(x)的长方形，重复多次取平均值

假如均匀采样，即$X_i$服从均匀分布

![](\图片\QQ截图20210407200058.png)

对于一般采样

![](\图片\QQ截图20210407200503.png)

#### 要求

1 样本越多，偏差越小

2 积分域在X上

### 路径追踪（对于每个点只考虑一根光线）

#### whitted style 的问题

（1）光线到漫反射就停止，开始着色了

（2）漫反射后的光线没有显示出来

#### 使用渲染方程的困难点和解决办法

如何计算定积分的值--蒙特卡洛积分

只考虑直接光照，确定f(x)（积分号后的一串），确定p(x)（1/2π，因为只考虑半个球面）

​		![](\图片\QQ截图20210407202915.png)

![](\图片\QQ截图20210407203233.png)

伪代码

![](\图片\QQ截图20210407203509.png)

加上别的点（间接光照）

![](\图片\QQ截图20210407203837.png)

但依然有问题

1 光线数量会爆炸，只有n=1不会爆炸。

这就是**路径追踪**，**找到了视点和光源的一条路径**，但噪声很大

![](图片\QQ截图20210407204336.png)

从像素点找N个样本中的位置，做出N条光线，求出他们的光照，取平均，也是一种蒙特卡洛积分

![](\图片\QQ截图20210407204740.png)

2 **递归的停止条件没加**

**不能简单的设定一个弹射次数，能量会损失**

解决方法：**俄罗斯轮盘赌**

设定一个概率P，让递归停止

假如在概率P内，将渲染结果放大为:$L_o/p$

否则结束，返回0

原因，这是一个0-1分布，期望为$L_0/P*P+0=L_0$

伪代码

![](\图片\QQ截图20210407205659.png)

3 效率不高，假如每个像素取的样本小，得到的效果不好

原因：由于采样均匀，能不能遇到光源很靠运气，有很多光源浪费了

解决方法：在光源上取一块面积dA积分、采样

将dA投影在单位圆上，来得到对应的$d\omega$

![](\图片\QQ截图20210407210650.png)

重写渲染方程，变量替换

![](\图片\QQ截图20210407210815.png)

4 没有判断光源是否可以直接达到点p

#### 最终方法

1 光源直接贡献（判断光源是否可以直接达到点p）

2 间接光照贡献

伪代码

![](\图片\QQ截图20210407211109.png)

结果与真实情况几乎一模一样

![](\图片\QQ截图20210407211824.png)

# 第九讲 材质与外观

材质==BRDF(决定了光形成的方式，就是作业中的f_r)

## 反射

![](\图片\QQ截图20210409105519.png)

## 折射

![](\图片\QQ截图20210409111219.png)



**全反射**产生条件：当光从密的地方进入稀疏的地方

![](\图片\QQ截图20210409111733.png)

## 菲涅尔项

### 现象

垂直向下看的时候，几乎看不到反射；水平看过去比较明显

 ![](\图片\QQ截图20210409112519.png)

光和物体平行，几乎所有能量都被反射；垂直的时候大部分折射

绝缘体的菲涅尔项

![](\图片\QQ截图20210409112610.png)

导体的菲涅尔项，比如铜制的镜子，垂直的时候反射的光依然很大

![](\图片\QQ截图20210409112901.png)

### 计算

复杂版

![](\图片\QQ截图20210409113039.png)

简单版Schlick's approximation

![](\图片\QQ截图20210409113135.png)

## 微表面模型

### 概念

假设物体表面粗糙

1 从远处看是**平且粗糙**的，材质外观

2 从近处看是凹凸不平的，每个小的微表面是镜面，不同的几何

### 微表面的BRDF

根据微表面的法线分布分布

大致朝前，是雾面的

朝四面八方，是漫反射

![](\图片\QQ截图20210409141630.png)

有多少光从wi反射到wo？

F：菲涅尔项

D(h):wi和wo的角平分线出大概分布多少法线

G：当光几乎平行地经过表面，前面的微表面会遮挡后面的微表面，用该项来修正

![](\图片\QQ截图20210409142205.png)

## 各向同性/各向异性材质

各向同性：微表面各方向法线分布一致

各向异性：微表面各方向法线分布有方向性

![](\图片\QQ截图20210409143334.png)

## BRDF总结

### 性质

1 非负性，f_r>0

2 线性，本身可以分成几块，再加起来

3 可逆性，交换入射和出射方向，f_r不变

4 能量守恒

5 各项同性（数据只需要存储三维）、各向异性

### 测量

从四面八方打光，并从四面八方测量

![](\图片\QQ截图20210409144931.png)

# 第十讲 渲染前沿技术

## 光线传播

### 概念

1 无偏估计：估计的期望是正确的

2 有偏估计：估计的期望是不正确的

### 双向路径追踪（bidirection path tracing BDPT）

无偏估计

从光源生成一部分路径，从相机生成一部分，中间连起来

![](\图片\QQ截图20210409151600.png)

### Metropolis(人名) light transport（MLT）

无偏估计

好处：**适合复杂的困难的光路传播**

坏处：不知道什么时候光线会收敛

​			局部性比较强，导致有的地方收敛了，有的地方没有，导致抖动比较大

**马尔科夫链**的蒙特卡洛方法

根据一条采样的光线，在它周围生成其他的采样

局部效果比较好

![](\图片\QQ截图20210409152605.png)

### 光子映射（photon mapping）

有偏方法

#### 优势 

光的聚焦所显示的图案（caustics）和处理specular-diffuse-specular（SDS）

#### 实现方法（其中一种）

1 从光源出发，直到光子打到漫反射（diffuse）表面后停止

2 从相机出发，直到打到漫反射（diffuse）表面后停止

3 计算局部的密度估计，由于光子分布越集中的地方越亮，所以对于每一个观察点我们取周围最近的N个光子，计算N个光子所占的面积A,N/A就是密度

4 N大效果好，但是会糊；步骤1多发射一些光子，效果会更好，有偏但一致

模糊==有偏

样本足够多就不模糊==一致

### Vertex connection and merging

结合了BDPT和photon mapping

### 实时辐射度方法（Instant Radiosity）

认为已经照亮的地方就是光源，用这些光源去渲染别的点

问题：1 缝隙会出现一些不该出现的发光点

​			 2 镜面物体做不了	

## 外观建模

### 非表面模型

#### 散射介质

雾、云

光线穿过这些介质的时候，会被吸收也会被散射

![](\图片\QQ截图20210409160954.png)

怎么散射？

由**Phase function**决定（类似BRDF）

应用：游戏、动画场景

#### 头发

头发上的高光有白色的也有有色的

1 kajiya-kay 模型

把打到头发上的光分为漫反射和高光，效果很差

2 **Marschner** 模型 用的比较多

有的光反射reflection，有的光穿进去再出来T（transmission）T，有的光穿进去在内壁反射再出来TRT

把头发的一小段当做一个圆柱体，有外表面和内里组成，内里的色素多就越黑

![](\图片\QQ截图20210409162029.png)

人和动物的毛发都由三层组成：表面、中间、髓质（光遇到它会散射），但是动物的髓质是很大的，所以人和动物的毛发不能一概而论

使用 **双层圆柱模型**

#### 颗粒材质（granular material）

### 表面模型

#### 半透明（translucent ）材质

translucent  光即会穿过也会在里面散射

比如：玉石、水母

使用**BSSRDF**，光由一个点进入物体，并会从其他点出来

用两个光源来近似

#### 布料

一系列缠绕的纤维

纤维缠绕成股，股再缠绕成线

解决办法：

1把线当成体积，计算的时候分成很小的体积，计算量很大

2每个纤维都渲染

# 第十一讲 相机、透镜、光场

## 相机

传感器上每一个点记录了当时的Irradiance

### 视场（field of view fov）

焦距越小，视场越大（广角）

![](\图片\QQ截图20210409183459.png)

定义**焦距**指的是对于**35mm**格式的胶片为基准

### 曝光（exposure）

exposure = time * irradiance

快门留的时间越长，进入的光越多，越亮

###  IOS（gain）

简单的在照片上线性提高曝光度，噪声也会被放大

### 光圈

使用FN来表示，只关心N是多少，F只是个标识

### 快门

控制光能进来多久

快门时间越长，运动模糊越明显

运动模糊不一定是坏事

## 透镜

假设薄透镜可以改变焦距

使用透镜组可以实现

 焦距、物距、像距

![](\图片\QQ截图20210409194725.png)

远处的物体模糊的原因，成像平面不在相距

光圈越大，越模糊

## 景深 depth of field

成像在理想成像点的一定范围内，我们认为是锐利的

这个范围我们称为景深

![](\图片\QQ截图20210409201048.png)

## 光场（lumigraph/light field）

### 全光函数

彩色照片，两个角度一个波长（表示颜色）

![](/图片/QQ截图20210410092656.png)

电影，加个时间

![](/图片/QQ截图20210410092836.png)

全息电影（vr），加个位置坐标，在任何时间、任何位置、任何角度看到的颜色

![](/图片/QQ截图20210410092930.png)

由光路的可逆性，看到物体可以理解为物体的包围盒上任意一点向各个的地方发射的光的情况

**光场：物体（物体的包围盒）任意一点向各个的方向的光的强度，因此有了光场就可以知道从任意角度看向物体能看到什么**

![](/图片/QQ截图20210410093643.png)

### 光场定义（参数化）

定义两个平面，光分别在这两个平面上的位置（u，v） （s，t）

![](/图片/QQ截图20210410094626.png)

### 光场照相机

先拍，再聚焦

在原本的感光元件处放置微透镜，让光中的不同颜色分开，分别记录在后面的感光元件上（irradiance->radiance）

![](/图片/QQ截图20210410100306.png)

如何得到普通照片，比如对于每一个微透镜都取最下面的光线，就得到了相机从下面拍的照片，都取中间的光线，就得到了从中间拍的照片，就像在移动相机

**相当于相机记录了整个光场**

![](/图片/QQ截图20210410100809.png)

# 第十二讲 颜色和感知

## 颜色

颜色是人感知的结果

人眼视网膜感应部位（s m l）对不同波长的感知，让人看到不同的颜色，但个体之间有很大差异

![](/图片/QQ截图20210410104605.png)

## 加色系统

计算机表示颜色的方式

![](/图片/QQ截图20210410115157.png)

## 标准颜色空间

sRGB

把X，Y，Z归一化，只需要记录两个值

![](/图片/QQ截图20210410121513.png)

### 色域

不同颜色空间表示颜色的范围

### 互补色

黑白、红绿、黄蓝

颜色本身是相对的

其实两个颜色是一样的

![](/图片/QQ截图20210410123142.png)

## 减色系统

在打印中用的很多

黑色可以调出来，但是黑色用的多且便宜，所以加了个黑色

![](/图片/QQ截图20210410123359.png)

# 第十三讲 动画/模拟

## 关键帧动画 keyframe animation

给出关键帧，关键帧之间插值

## 物理模拟 physical simulation

根据牛顿定律 F = ma

建立物体间的相互作用力

### 质点弹簧系统（mass spring rope）

一系列由质点和弹簧组成的系统

胡克定律

![](/图片/QQ截图20210410140112.png)

一般情况，弹簧长度l

![](/图片/QQ截图20210410140320.png)

假如不加入摩擦力，会一直弹下去，b点指的是速度

![](/图片/QQ截图20210410140700.png)

但只能描述外部的力，弹簧内部的损失没法表示

![](/图片/QQ截图20210410141215.png)

### 粒子系统

1由大量粒子组成

2计算内部（粒子和粒子之间的，引力斥力摩擦力空气阻力碰撞）力和外部力

3更新粒子位置和速度，有一些消失

4渲染

适合表现一些魔法的特效

## 运动学forward kinematics

定义一些关节、骨骼，让他们的旋转

### 逆运动学

给你动作，来计算关节、骨骼是怎么旋转的

问题：可能无解或多个解

## Rigging

给物体添加造型

设置一些控制点，控制物体

## 动作捕捉 motion capture

优势：

贴近真实

得到结果快

劣势：

准备起来复杂

可能不符合艺术需求，需要调整

## 单粒子模拟single particle simulation

### 常微分方程

![](/图片/QQ截图20210410151558.png)

### 欧拉方法（显式、前向）

#### 定义

x点为速度，根据上一帧位置/速度，更新下一帧的位置/速度
$$
\Delta t越小，效果越好
$$




![](/图片/QQ截图20210410151757.png)

#### 问题

但结果很不稳定，比如下图的螺旋形

 

![](/图片/QQ截图20210410152418.png)

#### 解决办法

1 中点法，用两次欧拉方法，第二次是对中点用

2 自 适应步长，计算中点位置，假如两次位置变化不大，或者步长已经很短了，就停止

### 欧拉方法（隐式、后向）

#### 定义

用下一帧更新速度、位置

![](/图片/QQ截图20210410153840.png)

## 刚体模拟 rigid body simulation

 ![](/图片/QQ截图20210410155444.png)

## 流体模拟 fluid simulation

1 假设流体是由大量的刚体小球组成的

2 假设水不可压缩

3 当某一部分的密度不对时，需要做一些修正（梯度下降）

## 欧拉视角和拉格朗日视角

拉格朗日视角：每一个粒子都做对即可（质点法）

欧拉视角：对一个网格每一帧穿过的物体（网格法）

![](/图片/QQ截图20210410160616.png)

